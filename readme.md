NIO技术和IO技术的区别
IO是面向流的，除非使用缓冲技术，否则每次总是读取一个字节（疑问？）
NIO是面向缓冲区的，每次读取数据都会先缓冲起来，当然这样的效率就比流要快得多
NIO的核心对象
通道：数据的写入读出都要通过通道对象Channel，跟IO的流有点相像，但是这里的通道可以用于读写操作。
缓冲区：缓冲区是包含要写入或者刚读出的数据，任何时候通过NIO读取数据都是读取缓冲区的数据的。
记住：发送给一个通道的数据都要先放到缓冲区中，同样，从通道读取的数据也都要读取到缓冲区中。
缓冲区实际包含一个数组，一般是字节数组，也有其他实现，比如说，字符数组，布尔数组等等。
缓冲区有一个继承体系，如上面所讲的，接口是缓冲区Buffer ，其字节，字符等数组的缓冲区都是它的实现类。
利用NIO技术来读写文件
示例程序：NIOExample.java




通道Channel的一些方法介绍和属性介绍
position  指针，指向下一个要读取的元素或者要写入的数组元素位置。
limit  表示还未读取多少数据或者写入了多少数据
capacity  存储在缓冲区的最大数据量
clear()    将 limit 设置为capacity 相等，如果是在读取的环境下设置，就表示还有capacity数据还未读取，也就是说，通道的数据一个都没动过，换句话说，缓冲区的空间等待填充
				position 设置为0 ，表示下次读取将从缓冲区的 数组的第一个元素开始读取
flip()       将 limit 设置为当前的position，如果是在写入的环境下，就表示还未写入的数据和往缓冲区填充的数据大小一致。
				将 position 设置为 0，下一次写入数据，也就是第一次写入数据时，将从缓冲区的第一个字节开始写入。
remaining  计算还有多少字节还未读完。如果要把缓冲区的数据输出到控制台上，这个方法就可以派上用场，但是，实际上这个方法是limit-position。
					所以调用这个方法前，要调整一下两个值
				
				
				
				
缓冲区ByteBuffer的读取和推入数据方法的介绍
读取缓冲区的数据
    byte get();    									每get一次，读取一个字节数据，同时指针指向下一个元素，没错，读取的是指针指向的字节
    ByteBuffer get( byte dst[] );		把一组字节写入缓冲区中
    ByteBuffer get( byte dst[], int offset, int length );  同上，不过是可以指定起始位置和结束位置
    以上都是需要根据指针的limit的情况来读取数据的，下一个就不是了，指定一个自己的指针，每次读取都是这个值。
    byte get( int index );
 写入缓冲区的数据
     ByteBuffer put( byte b );
    ByteBuffer put( byte src[] );
    ByteBuffer put( byte src[], int offset, int length );
    ByteBuffer put( ByteBuffer src );
    ByteBuffer put( int index, byte b );
    没什么好介绍的，最后一个是绝对的，不依赖指针和limit而已。
    
    
    
    缓冲区的深入理解
	    现在应该知道怎么创建缓冲区了吧：ByteBuffer buff=ByteBuffer.allocate(1024);
	    或者直接用现有的数组转换为缓冲区：
	    byte array[] = new byte[1024];
		ByteBuffer buffer = ByteBuffer.wrap( array );
		这种情况好像蛮危险的？你可以直接访问array这个数组直接获取缓冲区的内容。
	缓冲区分片
		slice() 方法根据现有的缓冲区创建一种 子缓冲区 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。
		就是字面意思，别想太多。
		示例程序：NIOBufferExample.java
		将演示如何共享的。。
    缓冲区只读：字面意思，创建一个只读缓冲区的方法为：调用缓冲区对象的asReadOnlyBuffer() ，将一般缓冲区改为只读缓冲区  示例程序：NIOBufferExample.java
    直接缓冲区：就目前理解的来说，用只读缓冲区可以提高读写效率。因为这种缓冲区的内存是有本地方法提供的，而非java堆内存。
    						  而非直接缓冲区每次读写操作都会产生很多临时的缓冲对象。
    						  但是直接缓冲区的创建和销毁会耗费很多资源。这是它的缺点
    						  调用ByteBuffer.allocateDirect( int size);获取一个直接缓冲区。
    						  其使用和非间接缓冲区一样，这里就不在赘述了。
    内存映射文件：这又是一种读和写文件数据的方法。比一般基于流或者基于通道的文件读写会快一点。
    					  		 其实现是将文件的数据变为内存中的数据来实现的。（基于通道的不也是这么做的么？）
    					  		 而且是只有实际读取或者写入的时候才会映射到内存去。
    					  		 现代操作系统都有把文件映射到内存的功能，java利用它的功能罢了。
    					  		 原文说，只要修改内存数组的一个元素，其文件内容也会随之改变。。。蛮危险，也蛮方便的。
    					  		 创建一个内存映射对象的方法是
    					  		 MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, 0, 1024 );
    					  		 字面意思，这个映射对象是可读可写的，大腿想都知道可以创建只读的内存映射。。。
    					  		 然后内存映射只是这个文件的其中1024个字节罢了。
    					  		 还有：MappedByteBuffer其实是ByteBuffer 的子类
    					  		 接着：内存映射对象并不依赖创建它的通道，你就算把通道关了，对内存映射对象的修改还是可以在银盘的文件看到的（前提是模式为读写！）
    					  		 小疑问：理论上来说，把文件流关闭也是同样的吧。正解。
    					  		 小猜想：关闭通道底层其实就是关闭流吧。
    					  		 示例程序：NIOBufferExample.java
    分散和聚集缓冲区
    	顾名思义，就是使用多个而不是单个缓冲区来完成对数据的读写操作。
    	分散的读取和普通的通道读取并无什么不同，只不过它将数据读到缓冲区数组而非单个缓冲区。同理
    	聚集的写入也只是把数据写入到缓冲区数组而非单个缓冲区里面。分散和聚集的数据读写有利于实现复杂的数据格式。
    	比如说有一个消息被划分为头部消息和正文消息，发送时就可以将这个消息分两部分放到缓冲区里面。
    	读取时也可以读出来两部分的内容。
    	聚集用于写
    		可以通过获取ScatteringByteChannel 通道对象。
    		该通道对象有一个write方法，允许接受缓冲区对象数组，从而实现聚集缓冲区写入数据。
    	分散用于读
    		可以通过获取GatheringByteChannel 通道对象。
    		该通道对象有一个read方法，允许接受缓冲区对象数组，从而实现往每一个缓冲区写入数据
    	示例程序：ScatteringAndGatheringExample.java
    	教程附带的程序是Socket版的，并且只有客户端。现在写不出来Socket程序了，该示例程序就这样吧。
    文件锁定
    	NIO提供的文件锁并不阻止任何形式数据访问，只是一种劝告式的锁定（真的？）
    	锁分两种
    	排它锁：锁定某文件或者某文件的某个部分，那么其他用户就无法获取特定文件或者特定文件的某个内容的锁
    	共享锁：反之，如果你用该锁锁定某个文件或者文件的某个部分，其他用户也可以获取这个锁，但是他们获取不了排他锁。
    	文件锁定不总是为了保护文件为目的，你可以锁定一个文件单独来写，而不会受到其他程序的干扰。
    	示例程序：FileLockExample.java
    联网和异步IO
     	解释一下异步IO.
     	传统的IO，在调用read方法时，会堵塞，直到有数据可以读取的情况下才会解除堵塞。
     						  在调用write方法时，也会堵塞，直到有数据能够写入为止。
		异步IO,就不会堵塞了，甚至你可以注册事件，比如说，数据可以读取或者写入啦，或者新的Socket连接进来啦等等
		示例程序：传统的Socket客户端和服务端架构，接受数据并返回数据。好吧，这个程序应该叫做服务端
								但是这个服务端比较6一点，它能同时监听多个端口而不用开启一个一个线程去监听。
								以前写的Socket通信每一个连接来read的时候都会堵塞。这样另外一个连接来的时候只能为其开启另一个线程。我将写这个程序来终止这个时代
		知识点：Selectors对象
						注册监听事件用的就是这个对象
						.....Socket通信，暂且留着吧。不想写这个了
	独家大派送：字符集
		如何使用 Charsets 处理文本数据？
		包括：为给定的字符编码创建 Charset，以及使用该 Charset 解码和编码文本数据。
		CharsetDecoder对象：编码器 ，顾名思义，就是用于将文本信息提供字符集编成字节码。
		CharsetEncoder对象：解码器，顾名思义，就是讲字节数据编成文本信息。
		示例程序：从文本读取数据，并将数据写入到另一个文件
		NIOTextCopyExample.java
								    	
    					  		 
    异常：
    BufferOverflowException：这个异常是在我执行缓冲区的put方法时发生的，put方法对其解释是：如果此缓冲区中没有足够的空间
    看了一下源代码：发现是put当前数组大小如果是大于remaining()时就会发生此异常，remaining()这个是用limit-指针的值。
    									问题很明显了，我之前还把缓冲区的数据输出一遍，导致指针指向了缓冲区的最后一个元素。
    									remaining()当然返回0了。
    									简单调用一下缓冲区对象clean，令指针归0，limit指向缓冲区的size（本来就是指向size）。
    									理论讲完了，教训是：
    									如果你之前将缓冲区输出一遍，记住输出后要调用一下clean。以防不测。。。
    									
    
    
