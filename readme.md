# Java基础
包含一下内容，欢迎补充

# 一：语法

## 1.1：final的小知识

其实final的作用一般java程序员都能理清楚,但是我觉得,final的String会比较特殊一点
举例子

```
     String a = "hello2";
        final String b = "hello";
        String d = "hello";
        String c = b + 2;
        String e = d + 2;
        System.out.println((a == c));  //true
        System.out.println((a == e));  //fasle
```

这段代码执行完的结果如上所示
我们知道`==`判断的是变量的引用是否相同,或者说指向的堆地址是否一样
如果咋一看代码,`c`和`e`都是在运行时使用字符串的连接,连成一个新的字符串对象,也就是说,指向的是新的堆内对象.所以至少第一个判断就不应该为true才是..
但是实际上,它的确为true.其原因是常量b在编译时期,就能确定值,编译器就会把所有b变量都替换成那个常量值,类似于c语言的宏替换.
所以实际上,编译后的结果是

```
 String a = "hello2";
        String b = "hello";
        String d = "hello";
        String c = "hello2";
        String e = d + 2;
        System.out.println(a == c);
        System.out.println(a == e);
```

运行时,也是按照这个编译后的代码去运行的
字符串变量声明所用的字符串都一样,运行时会使用在堆里面同样的字符串常量. 
以上

## 1.2：switch参数

这里只讲一点，就是switch能作把什么作为参数

告诉你，只有int

那为什么网上说，`byte`  `char`  `String` `short`  都可以作为switch参数呢？

那是因为上面的类型都可以直接转成int，而且不会丢失精度。

`String`是很特殊的一个，从jdk1.7之后，才支持作为String的参数，其实是编译器做了优化。

编译源文件后，String会用它的哈希码，也是int类型，作为switch参数



## 1.3 异常

### 1.3.1 异常的几个冷知识

1. Error会回滚吗？

   因为回滚依赖的是catch子句，如果错误不能被catch子句捕捉到，那就不用谈了  
   答案：能捕捉到，而且Error的异常能使事务回滚，前提是设置好回滚异常

# 二：常见类知识

## 2.1：集合框架

1. 演示fill方法和reverse方法和replaceAll方法并实现一个部分替换的方法

### 2.1.1：Iterable 和Iterator

1. 有两个类

一个是`java.lang.Iterable`   意味可以迭代的

一个是`java.uitl.Iterator` 意味迭代器

这两个类不要混淆了

第一个类是基本的所有list都会实现的。

另一个是迭代器，可以实现某个容器的迭代模式

要是有某个方法的参数接受`Iterable`对象，然后惊奇的发现可以传list集合进去，别自以为形参是迭代器对象，实参就可以是list集合的，不存在的，tan90

### 2.1.2泛型

#### 2.1.2.1 上界通配符

Plate<？ extends Fruit>  上界通配符，?表示Fruit类以及Fruit的派生类（子类） 

代码示例

```java
  public class Plate<T>{
  	private T item;
  	public Plate(T item){
  		this.item = item;
  	}
  	public void set(T item){
  		this.item = item;
  	}
  	public T get(){
  		return this.item;
  	}
  }
```

这样的话，Plate<? extends Fruit> p 这个引用变量就可以接受所有Fruit以及Fruit的子类对象了  

如: `Plate<? extends Fruit> p = new Plate<Apple>(new Apple())`   水果盘子可以放苹果，很科学  
不过，这个水果盘子只能放一次水果，就是在它new的时候，你再执行set方法就不行了。  
虽然编译器知道水果盘子里面放的是水果，可是它并不知道是什么水果，所以你放什么水果进去它都不知道能不能匹配，当然就不让你放了。
取水果是有效的，因为编译器虽然不知道你

放的是什么水果，可它至少是水果，并且还是对象。
只要用这两种类型来接受就OK了

#### 2.1.2.1 下界通配符

Plate<？ super Fruit> 下界通配符，'？'表示水果以及水果类的父类。
换句话说，这个盘子可以放水果和食物。。​

> PS：虽然说可以放食物，你可不能往里面放猪肉。它可以放的是食物的实例，因为食物是水果的父类。
> ​	        猪肉是水果的父类吗?显然不对

下界通配符 可以这么使用： `Plate<？ super Fruit> plate = new Plate<Food>(new Food())`
这样的话编译器知道你搞了一个盘子，里面可以放水果或者水果以上的食物，但具体是什么它也不清楚。  
所以放苹果是合适的，苹果既是水果，又是食物。  
但是你不能放水果的父类，因为可能这个盘子一开始new的时候只允许放水果。  
说的再直白一点就是编译器虽然不知道你葫芦里卖的什么药，可它起码是药，放药进去就行了。  
其实不太科学的说，我new了一个放食物的盘子，居然只能放水果，够憋屈的。  
更憋屈的还有，你取出来的话，只能用Object来接受...还是那句话，编译器不知道你放进去的是什么东西。  
所以只能推断为最顶层的基类：Object。你再怎么放东西，它最终都是一个对象  
以上。

## 2.2：反射
1. 演示最基础的方法

## 2.3：JDBC
1. 批处理
2. DML语句
3. oracle的PLSQL语句
    附上PLSQL的程序代码
    <pre>
    create or replace procedure p
    (v_a in number,v_b in number,v_sum out number,v_temp in out number)
    is
    begin
    v_sum:=v_a+v_b;
    v_temp:=v_temp+1;
    end;
    /
    </pre>
4. 不定参数
5. 可以滚蛋的结果集
6. 事务处理
7. 结果集更新

## 2.4：字节流
注1：InputStream对象的available可以返回这个字节流中可以读取的字节数  

## 2.5：BigDecimal的学习

构造函数  
​		`BigDecimal(double val); ` 
​		`BigDecimal(int val);`  
​		`BigDecimal(String val);`  
分别可以将double，int，String代表的数字转成BigDecimal对象 



## 2.6 路径问题

### 2.6.1 取得resources文件

如何在Maven项目中，用相对路径取得resources里面的文件呢？
用这个代码  `类名.class.getResourceAsStream("/文件名");`
具体原理不是很清楚。大概就是从classpath路径下搜索所有符合条件的文件吧



## 2.7 Socket网络编程

怎么把经过url编码转换成中文？  
假设现在通过Socket协议连接时客户还往连接的url地址加一些中文参数，那么怎么在服务端把这些文字解码成中文呢？  
说来也挺简单的  
`new String(URLDecoder.decode(要转换的字符串, "utf-8")`  

# 三：并发编程

## 3.1线程的并发问题
具体请查看测试代码里面的com.cxh.thread包，有一个ThreadExtendsImplTest
演示的几个方面的并发问题代码
1. 演示了线程的抢占性

2. 演示了售票程序，也就是线程并发问题。
    指的一提的是，这个线程并发问题解决的还不是完美。
    因为锁的判断要消耗一定的系统资源，所以还可以优化

3. 锁的优化在设计模式中的单例设计模式中。  
    关于单例模式的饿汉式和冷汉式  
    由于线程的并发，会产生一些问题  

4. 特别说明的是，在同步代码块中（也就是被锁起来的代码中），如果线程wait了。

  那么与之相关的锁会被释放。不用担心在锁中睡眠时锁没有释放。

5. 顺便讲一下并发线程的锁类型。一般情况下，Synchronizer代码块里面需要自己设置锁对象

   其他的，成员方法加锁的话，锁对象是this。

   静态方法加锁的话，锁对象是Class对象

   以上，不想为这个知识点码代码了，各位记一下，脑子里有一个映像就行

 6. 特别说明，如果要执行notify或者signal的代码，必须在同步代码块里面执行。
     否则抛一个java.lang.IllegalMonitorStateException异常你都不知道怎么肥事。



# 四：深入理解

## 4.1引用面面观

你可能只听说过引用，却不知道引用其实分为四类

以下介绍这四种引用

1. 强引用 ： 这个引用是我们经常用的，形如`String a=xxx` 或者`Integer i =1`;

   都是强引用(`Strong Reference`)

   这些引用在垃圾收集时，都不会被回收，即使内存不足

2. 弱软用(`Soft Reference`)，这个需要特殊的写法才能实现

   `SoftReference sr=new SoftReference(new Person());`

   这个代码建立的就是弱引用，稍次于强引用,这句代码建立的`person`对象，是可以被垃圾收集器回收的

   只不过只有在堆内存空间不够的情况下，才会回收。

3. 弱引用(`Weak Reference`)  需要这么实现

   `WeakReference wr=new WeakReference(new Person());`

   在垃圾收集时，只要上面那句代码创建的`person`对象被发现了，立马收集，不留余地

   >我觉得用这种引用来设计缓存是可以的，因为不像软引用，它必须得内存不够了才会回收。
   >
   >这样会导致GC的时刻的提前到来。
   >
   >弱引用它随时随地都可以回收，所以不会积攒对象到内存不足

4. 虚引用`Phantom Reference`  其实也跟弱引用一样，在垃圾收集时，随时可被回收

   但是还是有区别，虚引用在使用时必须和引用队列联合使用。以便在虚引用所引用的对象被垃圾回收时

   在程序中，可以收到通知



## 4.2 基本类型的一些有趣的地方

`byte、char、short`  这些类型自己相加后得到的类型，是`int`类型

至于为什么是这样子的，是因为对于这些类型，jvm虚拟机里面并没有对应的指令去运算。

实际上用的是int的指令去运算的，也就是它们在运行时会转成int去计算，当然得到的结果也就是int了

> 可以强制类型转换，不过不建议，会丢失精度



## 4.3:JDK7的comprae方法

1. JDK1.7升级后，对comprae方法做出了新的限制，该限制如果不被满足，在使用Sort将会抛出一个异常

   ```
   Comparison method violates its general contract
   ```

   解决办法有两个，一个就是加个`-Djava.util.Arrays.useLegacyMergeSort=true`

一个就是修改你的代码，符合新的要求

为什么会报错呢？

究其原因，是因为JDK1.7 后，Sort方法内部使用的算法改成了TimeSort

这个算法在使用不科学的排序时，就会抛如上的异常。

## 4.4 java的引用之争

java传对象给方法时，传的是对象的地址，方法体内用另一个参数来接受这个地址，若是方法体内操作这个地址
亦即操作对象，set一个属性什么的。方法体外仍可以得知这个改动。。<br/>
但是，如果方法体内另一个参数接受到传进来的对象的地址后，擅自把该参数指向另一个地址，也就是new。<br/>
那么。方法体外的对象和对象引用不会受任何影响<br/>
地址本身就是一个值，java把地址拷贝了一份发给方法，所以也就是说为什么java只有值传递的原因了。
要是引用传递，还拷贝个毛。
偷来的一个截图为例<br/>
![吔屎啦，图片显示不出来](https://github.com/XHang/Notes/blob/master/java%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%A4%BA%E4%BE%8B.png)



## 4.5 类的静态变量和静态代码块执行时机

答案：
初始化

问题：那么什么时候进行初始化呢？    
可不是类加载时，比如说，Class class= A.Class  
这个时候类加载了，但却没有初始化  
类的初始化主要由下面几个因素触发  

当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）
当调用某个类的静态方法时
当使用某个类或接口的静态字段时
当调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时
当初始化某个子类时
当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类）

这是一般的情况，但是从web环境下运行，类的静态成员也是由以上的因素触发初始化吗？    
某人认为：调用前就初始化了，因为静态成员是作为一个类变量存在，在这个类被加载到虚拟机里面时(或者tomcat运行容器)就已经被初始化了    
实验下。。。  
实验条件：标准的SSM项目，三个测试  

1. 仅写好类  
2. 调用一下类.class  
3. 调用类的静态属性  
   结果只有调用类的静态属性才会触发类的初始化，结论，百度都是骗人的  

但是，比较特殊的是，一旦类初始化失败，在下面的web应用中，将不能再使用这个类了。  
除非重启并正确地初始化该类  

# 五：Java规范

1. 根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。

2. 机器永远是对的，**未测试代码永远是错的**，别人写的代码不要轻易相信
   写接口的调用者也要清楚对方的接口的业务逻辑是怎么跑的。这样才能磨炼自己的接口更健壮

3. 实体类属性中基本数据类型最好设置为包装数据类型，这样如果这些数据缺失的情况下，不会设置为默认值。而是报空指针。
   避免设置为默认值后掩盖了原有的错误。

4. 在任务交付之前，一定要检查一遍代码
   包括但不限于
   1. 代码的健壮性（为空判断，空指针检查）
   2. 代码的隐患检查（没小心判断为空就直接调用）
   3. 代码的语义规范检查：包括变量名大小写规范，类名规范
   4. 功能性检查，能否完成功能。。
   5. 特别注意：拷贝后修改的代码更是要仔细检查一遍,代码的类名方法名是否注释是否过时！

5. 常量命名全部大写（很少用到，权且一记）

6. 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。

7. ​数组定义请用 String []  args 而不要用 String args [] 
   为什么？第一个这样写很明显的，前者是字符串数组类型，后者是它的应用。第二个这么写，前者很明显是字符串类型，后者是其数组类型的一个引用。
   单从语句执行情况没有区别，但是前者把数据类型和引用分开了，更清晰。
   况且，使用后者，万一出现这种情况，String args[],str ;也许你写的时候知道str是字符串类型，但是后来的维护人员想骂街，一行定义两个数据类型，坑！

8. 包名统一小写啊（开发很少需要写包名，自己写项目的时候就要注意了）\

9. 接口类中的方法和属性不要加任何修饰符号（public 也不要加）

   > 个人倒觉得无可厚非，加了更明显的标注接口的功能，再者，接口本来代码就不多。简洁嘛，也没多大必要
   > 标注是为了开发时注意点，个人写就随意了

10. 自己添加，代码里面的公有常量最好封装在一个工具包的枚举中，
    枚举出现的原因就是为了服务公有变量，枚举不能实例化符合工具类不能实例化这个需求。

11. ​接口类后缀名是Service，实现类后缀名是ServiceImpl

12.​枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。

13.  业务层数据层方法规范

      	1. 获取单个对象用getxxx
       2.  获取列表对象用listxxxx
       3.  获取总数什么的用countxxxx
       4.  插入方法的用insert或者save
       5.  删除方法用remove或者delete
       6.  修改方法用update

14. 抛异常时想清楚这个异常是什么情况的，不要直接在方法名上throws Exception 就行了

15. 额，那个，把不需要的引入去除掉。
16. 接手或者修改别人代码之前注意看别人是怎么实现了。。。！
17. 抛异常把异常信息说清楚点。。。还有封装代码时思考一下这么做值得吗？
18. 如果一个对象已经是注入的了，就不要用程序来再次修改它的状态​
    比如说有一个对象通过ioc注入，在使用时为了方便还在程序设置了几个对象属性。这是不合理




# 六：SSLSocket通信
首先认识下SSL协议吧

ssl协议的基本思路是采用公钥加密法，也就是说，客户端先向服务端请求公钥，然后用这个公钥加密信息。发给服务端，服务端再用密钥解密信息。
>  但是这样子有个问题，就是客户端不知道服务端发来的公钥是不是冒充的，所以一般来说，都会把公钥放在证书里面，只要证书是可信的，那么密钥就是可信的
>
>  然后其实客户端用公钥加密信息其他耗费的计算量会很大，那么如何减少耗用的时间
>
>  解决办法是每一次对话都生成一个会话密钥`session key`用它来加密信息，由于这个密钥是对称密钥，所以花费的时间会更小，然后公钥用来加密`session key`就行了

SSL的协议的基本流程是酱紫的

1. 客户端向服务端索要证书，获取公钥。
2. 双发协商生成一个对话密钥
3. 双方采用对话密钥进行通信

前两步，又称握手阶段

## 6.1：SSLSocket的详细过程

1. 客户端向服务端发起加密通信的请求，里面包含以下信息

   1. 我支持什么协议版本，比如说`TLS 1.0`版
   2. 一个客户端生成的随机数，**random1**
   3. 支持的加密方法，比如说`RSA`公钥加密
   4. 支持的压缩方法

2. 服务端接受客户端发来的信息，进行解析，然后发送响应给客户端。里面包含

   1. 确认协议版本。

      > 如果服务端不支持客户端的协议版本，加密过程结束

   2. 确认加密方法

   3. 服务端生成的随机数**random2**

   4. 服务端证书

      > 如果服务端需要客户端的身份验证，会在这一步要求客户端提供证书

3. 客户端响应

   客户端接受来自服务端的响应后，会校验服务端证书的有效性

   > 如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信 

   有效性通过后，客户端会从证书里面提取公钥，并向服务端发送下列三项信息

   1. 一个随机数。该随机数由公钥加密，防止窃听

      > 该随机数是第三个随机数了，也被称为`pre-master key `

   2. `编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 `

   3. 客户端握手结束通知。

4. 服务端响应--服务端接受来自客户端的信息后，发回响应给客户端，包含

   1. 握手结束通知
   2. `编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 `

客户端和服务端使用前面通讯获知的三个随机数，生成对话密钥，来进行下面的对话加密传输

> 注意点：前两次握手通讯都是明文传输的，所以窃听者可以看到前两次握手加密传的随机数。
>
> 整个加密传输是否安全，取决于第三次握手传输的随机数能不能被破解。

## 6.2：SSLSocket常用类介绍
1. `SSLSocketFactory`  这是一个工厂类，可以用于生成`SSLSocket `

   听名字就知道它是一个工厂类，用于产出对象的。

   想要获取`SSLSocketFactory` 可以通过`SSLSocketFactory.getDefault(); `获取

2. `SSLSocket`这个类继承自Socket类又提供了安全套接字。

   可以构造一个带有端口和IP的`SSLSocket`。

   主要可以通过`SSLSocketFactory`对象 的以下方法创建

   `*createSocket(String host, int port)* `

   `*createSocket(String host, int port, InetAddress clientHost, int clientPort)* `

   `*createSocket(InetAddress host, int port)* `

   `*createSocket(InetAddress host, int port, InetAddress clientHost, int clientPort)* `

   `*createSocket(Socket socket, String host, int port, boolean autoClose)* `

3. `SSLServerSocketFactory` 这个类跟`SSLSocketFactory`  大致功能相同，只不过执行

   `createServerSocket`拿到的是`SSLServerSocket`实例。

   用于构建服务端的安全套接字

4. `SSLServerSocket`这是一个服务端的安全套接字，类似于`SSLSocket`

## 6.3：SSL工作方式

有两种：

1. SSL连接不需要客户端验证，这个时候，与SSL服务端连接的客户端是什么都可以。阿猫阿狗也行。

   但是客户端和服务端连接是加密的，通过服务端的证书来加密

   这种情况下的工作方式是酱紫的

   1. 服务端为客户端提供证书，客户端验证服务端是否是合法的。

   2. 客户端生成`premaster secret `并使用服务端的公钥进行加密，发给服务端、

      公钥包含在服务端的证书中

   3. 服务端解密客户端发来的`premaster secret `

   4. 服务端和客户端通过`premaster secret `生成` master secret `,接着从` master secret `生成

      ` session keys `,这个是一个对称密钥，用于在会话过程中加密和解密信息并保持信息的完整性

   5. 在这个过程之后，客户端和服务端就就可以用`session keys`来进行加密通讯了

2. SSL连接需要客户端验证身份，这种情况下

   客户端需要发送证书给服务端，以便相互验证连接。

   除了客户端的证书验证外，其他工作流程没有任何改变，这种情况下，通讯客户端的用户名和密码验证变得多余

## 6.4: 专有名称解释

1. `jks` 是密钥库，里面存储的是密钥和证书.

   可以通过`keytool -genkeypair -alias myserver -keystore myserver.jks `生成密钥库

   这个命令行就是生成了一个名叫myserver.jks的密钥库，里面有一个密钥对(公钥和密钥)

   公钥包装在证书中，而证书和密钥存储在别名(myserver)命名的密钥库中

2. `csr  `即证书请求文件，可以把`csr`证书送给专门的CA认证去签名，就可以得到一个证书公钥文件

   `csr`证书文件可以通过这个命令生成

   `keytool -certreq -file test_server.csr -alias TEST_SERVER -keystore test_server.jks `

   这个命令行的作用就是从`test_server.jks `密钥库中，将`TEST_SERVER `对应的证书信息导出为证书请求文件。

3. `cer `这个就是证书文件了，可以通过证书请求文件由CA签名得到，也可以直接从密钥库中导出

   第一种方式，用第二步拿到的证书文件，用自己的密钥签名

   > 所谓自己的密钥，其实就是通过genkeypair 生成的

   签名的命令行是这个

   `keytool -gencert -infile test_server.csr -outfile test_server.cer -alias TEST_ROOT -keystore TEST_ROOT.jks `

   意思就是用`TEST_ROOT.jks `里面`TEST_ROOT`的密钥，来对`test_server.csr`证书请求文件进行签名，生成已签名的证书文件。保存在`test_server.cer`文件里面。



   第二种方式，就是从jks，密钥库中导出证书，命令行是这个

   `keytool -exportcert -alias TEST_ROOT -file test_root.cer -keystore test_root.jks `

   意思是从jks文件中读取`TEST_ROOT `关联的证书文件，并存储在`test_root.cer`文件中

4. 顺便介绍几个命令

   `keytool -importcert -alias TEST_ROOT -file test_root.cer -keystore TEST_SERVER.jks `

   该命令的作用是将证书导入到jks文件中，前提是jks文件不含`TEST_ROOT `别名的条目，否则就是更新证书，而不是导入证书了。



   `keytool – printcert – v – file test_server.cer `

   打印证书信息



   `keytool – list – v – keystore test_server.jks `

   显示jks文件的条目信息

5. 证书其实是以证书链的形式组织的，一个证书，在他变成证书之前需要被中级证书签署，而中级证书又要被根证书签署。这样就构成了一条证书链`根证书--> 中级证书---> SSL证书`只有当整个证书链的证书都是可信时，整个证书验证的结果才是可信。

6. 制作`TrustStore`即信任证书存储库

   假设你现在有一个证书，想用这个证书制作一个信任证书列表。可以酱紫做

   `keytool -import -alias serverkey -file server.crt -keystore tclient.keystore`

   这样就是把server.crt证书导入到tclient.keystore,信任证书列表了

# 七：JDK7升级信息

## 7.1 新增的类

1. Objects类，是Object的工具类  ，有Object的判空安全Equals



# 八：变量

## 8.1 字符串

单个字符的‘+’号连接并不是字符串连接，而是用ascll码相加

# 九：冷知识

1. 方法名可以类名一致，和构造方法唯一区别是，构造方法没有返回值
2. 实例方法不单单指public方法，private方法亦是  
3. long d = 2 是正确的，虽然单单写一个2，其实是int。这个应该用了隐式类型提升
4. 原生类就是java的基本数据类型
5. Integer 的可以直接用对象比较数字，它会自动拆箱哟
6. 记住，程序里面`^`这个的话，是按位异或，不是指数
7. 








